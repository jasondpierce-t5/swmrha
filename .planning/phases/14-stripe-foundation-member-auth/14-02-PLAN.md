---
phase: 14-stripe-foundation-member-auth
plan: 02
type: execute
depends_on: []
files_modified: [supabase/migrations/001_members_table.sql, src/lib/supabase/middleware.ts, src/app/auth/callback/route.ts, src/app/auth/confirm/route.ts]
---

<objective>
Create members database table with RLS policies and update auth infrastructure to support member accounts alongside admin accounts.

Purpose: Establish the member data model and route protection that the member portal (Phase 15) and payment flows (Phases 17-20) depend on.
Output: Members table SQL migration, updated middleware with /member/* protection, role-aware auth callback, email confirmation route.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/supabase/middleware.ts
@src/app/auth/callback/route.ts
@src/lib/supabase/server.ts

**Tech stack available:** @supabase/ssr, @supabase/supabase-js, Next.js 16.1.6
**Established patterns:**
- Three-client Supabase SSR pattern (browser/server/middleware)
- Middleware protects /admin/* checking app_metadata.role === 'admin'
- Auth callback at /auth/callback exchanges code for session, redirects to /admin
- RBAC via app_metadata.role (service role only can modify — secure by default)
- Existing tables: shows, sponsors, results (all with RLS)

**Constraining decisions:**
- Phase 9: app_metadata.role for RBAC — admin accounts have role='admin'
- Phase 9: Middleware route protection pattern
- Phase 9: Auth callback uses exchangeCodeForSession (PKCE flow)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create members table SQL migration with trigger and RLS</name>
  <files>supabase/migrations/001_members_table.sql</files>
  <action>
  Create supabase/migrations/ directory and 001_members_table.sql with:

  **1. Members table:**
  ```sql
  create table public.members (
    id uuid not null references auth.users on delete cascade primary key,
    email text not null,
    first_name text not null,
    last_name text not null,
    phone text,
    address_line1 text,
    address_line2 text,
    city text,
    state text default 'MO',
    zip text,
    membership_type text default 'individual',
    membership_status text default 'pending',
    membership_start date,
    membership_expiry date,
    stripe_customer_id text,
    avatar_url text,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
  );
  ```
  - Primary key is auth.users.id (uuid) — one member row per auth user
  - Include stripe_customer_id for linking to Stripe (Phase 17 will populate)
  - Default state to 'MO' (Southwest Missouri association)
  - membership_status: 'pending' (after signup), 'active' (paid), 'expired', 'suspended'
  - membership_type: 'individual', 'family', 'youth', 'lifetime'

  **2. Enable RLS:**
  ```sql
  alter table public.members enable row level security;
  ```

  **3. RLS Policies:**
  - Members can read their own profile: `auth.uid() = id`
  - Members can update their own profile (except membership_status, membership_type, stripe_customer_id — those are admin/system managed): use column-level check or just allow full update for now (Phase 16 will add admin management)
  - Admins can read all members: `(auth.jwt()->'app_metadata'->>'role') = 'admin'`
  - Admins can update/delete any member: same admin check
  - INSERT: Only the trigger creates rows (security definer bypasses RLS), so no INSERT policy for regular users needed

  **4. Trigger to auto-create member profile on signup:**
  ```sql
  create or replace function public.handle_new_member()
  returns trigger
  language plpgsql
  security definer set search_path = ''
  as $$
  begin
    -- Only create member row for non-admin signups
    if (new.raw_app_meta_data->>'role') is null or (new.raw_app_meta_data->>'role') != 'admin' then
      -- Set role to 'member' in app_metadata
      new.raw_app_meta_data := coalesce(new.raw_app_meta_data, '{}'::jsonb)
        || '{"role": "member"}'::jsonb;

      -- Create member profile from user_metadata
      insert into public.members (id, email, first_name, last_name)
      values (
        new.id,
        new.email,
        coalesce(new.raw_user_meta_data->>'first_name', ''),
        coalesce(new.raw_user_meta_data->>'last_name', '')
      );
    end if;
    return new;
  end;
  $$;
  ```
  - Use BEFORE INSERT trigger on auth.users so we can modify raw_app_meta_data
  - Skip member creation for admin accounts (they already have role='admin')
  - Extract first_name/last_name from user_metadata (set during signUp)

  **5. Create trigger:**
  ```sql
  create trigger on_auth_user_created
    before insert on auth.users
    for each row execute procedure public.handle_new_member();
  ```

  **6. Updated_at trigger:**
  ```sql
  create or replace function public.update_updated_at()
  returns trigger
  language plpgsql
  as $$
  begin
    new.updated_at = now();
    return new;
  end;
  $$;

  create trigger members_updated_at
    before update on public.members
    for each row execute procedure public.update_updated_at();
  ```

  Write the complete SQL file with comments explaining each section. DO NOT create a Supabase CLI project or run migrations — the SQL will be executed manually in the Supabase Dashboard SQL editor.
  </action>
  <verify>SQL file exists at supabase/migrations/001_members_table.sql and contains CREATE TABLE, RLS policies, trigger function, and trigger creation</verify>
  <done>Complete SQL migration file ready for manual execution in Supabase Dashboard</done>
</task>

<task type="auto">
  <name>Task 2: Update middleware and auth routes for member support</name>
  <files>src/lib/supabase/middleware.ts, src/app/auth/callback/route.ts, src/app/auth/confirm/route.ts</files>
  <action>
  **Update src/lib/supabase/middleware.ts:**
  Add /member/* route protection AFTER the existing /admin/* check:
  - /admin/* requires user.app_metadata?.role === 'admin' (existing — keep as-is)
  - /member/* requires any authenticated user (user exists). Redirect to /member/login if not authenticated.
  - All other routes pass through (existing behavior)

  Preserve ALL existing comments and the critical cookie handling pattern. Only add the /member/* check block.

  **Update src/app/auth/callback/route.ts:**
  Make the redirect role-aware after exchangeCodeForSession:
  - After successful code exchange, call supabase.auth.getUser()
  - If user.app_metadata?.role === 'admin' → redirect to /admin
  - Otherwise → redirect to /member (member portal dashboard)
  - On failure → redirect to /login (keep existing behavior)

  **Create src/app/auth/confirm/route.ts:**
  New GET route handler for email verification (token_hash flow):
  - Parse token_hash and type from URL searchParams
  - Call supabase.auth.verifyOtp({ token_hash, type })
  - On success: redirect to /member/login with ?confirmed=true query param (so login page can show success message)
  - On failure: redirect to /member/register with ?error=verification_failed query param
  - This route is separate from /auth/callback because email confirmation uses token_hash (not PKCE code exchange)
  </action>
  <verify>
  - `npm run build` succeeds
  - `npx tsc --noEmit` passes
  - Middleware file still protects /admin/* AND now protects /member/*
  - Auth callback redirects based on role
  - /auth/confirm route exists and handles token_hash verification
  </verify>
  <done>Middleware protects both /admin/* and /member/* routes. Auth callback redirects admin→/admin, member→/member. Email confirm route verifies OTP tokens and redirects to member login.</done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <action>Run members table SQL migration in Supabase Dashboard</action>
  <instructions>
    I've created the SQL migration file and updated the auth infrastructure.

    Now run the SQL in your Supabase project:

    1. Go to your Supabase Dashboard → SQL Editor
    2. Open the file `supabase/migrations/001_members_table.sql`
    3. Copy the ENTIRE contents and paste into the SQL editor
    4. Click "Run" to execute

    This creates:
    - `members` table linked to auth.users
    - RLS policies (members see own data, admins see all)
    - Trigger to auto-create member profile + set role='member' on signup
    - Updated_at trigger for automatic timestamps

    5. Verify in Table Editor: you should see the `members` table with columns (id, email, first_name, last_name, phone, etc.)

    6. **Configure email confirmation** in Supabase Dashboard:
       - Go to Authentication → Email Templates → "Confirm signup"
       - Change the confirmation URL template to:
         `{{ .SiteURL }}/auth/confirm?token_hash={{ .TokenHash }}&type=email`
       - This ensures email confirmation links route through your app (not Supabase's default redirect)

    7. **Ensure email confirmation is enabled:**
       - Go to Authentication → Providers → Email
       - "Confirm email" should be ON (this is the default)
  </instructions>
  <verification>
    - Members table visible in Supabase Table Editor
    - `npm run build` succeeds with updated middleware and auth routes
  </verification>
  <resume-signal>Type "done" when SQL is executed and email template is configured</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] Members table exists in Supabase with correct columns
- [ ] Middleware protects both /admin/* and /member/* routes
- [ ] Auth callback redirects based on user role
- [ ] /auth/confirm route handles email verification tokens
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Members table with RLS policies ready for member signup
- Trigger auto-creates member profile and sets role='member'
- Middleware protects member routes
- Email confirmation flow routes through /auth/confirm
</success_criteria>

<output>
After completion, create `.planning/phases/14-stripe-foundation-member-auth/14-02-SUMMARY.md`
</output>
