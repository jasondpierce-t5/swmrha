---
phase: 20-guest-checkout-additional-fees
plan: 01
type: execute
depends_on: []
files_modified: [supabase/migrations/009_additional_fees.sql, src/types/database.ts, src/lib/actions/fee-items.ts, src/lib/actions/fee-checkout.ts, src/lib/actions/fulfillment.ts]
---

<objective>
Create the database foundation and server actions for additional fee types (stall fees, banquet tickets, etc.) and guest checkout infrastructure.

Purpose: Establish the data layer enabling both member and guest purchases of configurable fee items, extending the existing Stripe payment infrastructure.
Output: Migration 009 with 2 new tables + payments schema changes, TypeScript types, admin CRUD + checkout + fulfillment server actions.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-show-entry-payments/19-01-SUMMARY.md
@.planning/phases/17-membership-payments/17-01-SUMMARY.md
@.planning/phases/17-membership-payments/17-02-SUMMARY.md

# Key source files
@supabase/migrations/006_payments.sql
@src/types/database.ts
@src/lib/actions/fulfillment.ts
@src/lib/actions/entry-checkout.ts
@src/lib/actions/show-classes.ts

**Tech stack available:** Next.js 16, Supabase, Stripe SDK, admin client pattern
**Established patterns:** Admin client for writes, fee_cents snapshot, checkout session pattern, idempotent webhook fulfillment, payment type dispatch
**Constraining decisions:**
- Phase 17: SELECT-only RLS for payments, all writes via service role admin client
- Phase 17: Idempotent webhook fulfillment with fallback payment creation
- Phase 19: Payment type dispatch in fulfillment.ts (entry_fees vs membership)
- Phase 18: fee_cents snapshot pattern for price protection
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration 009 for additional fee types, fee purchases, and payments guest support</name>
  <files>supabase/migrations/009_additional_fees.sql</files>
  <action>
  Create migration with three parts:

  **Part A: additional_fee_types table**
  - id (uuid PK, gen_random_uuid)
  - name (text NOT NULL) — e.g., "Stall Rental", "Banquet Ticket"
  - description (text nullable)
  - price_cents (integer NOT NULL) — fee amount in cents, consistent with show_classes.fee_cents pattern
  - category (text NOT NULL DEFAULT 'other') — e.g., "stall", "banquet", "vendor", "other"
  - show_id (uuid nullable, FK to shows ON DELETE SET NULL) — null means available for all shows
  - max_quantity_per_order (integer nullable) — null means unlimited
  - is_active (boolean NOT NULL DEFAULT true)
  - sort_order (integer NOT NULL DEFAULT 0)
  - created_at, updated_at (timestamptz NOT NULL DEFAULT now())
  - RLS enabled: SELECT for authenticated + anon (public purchase page needs access), admin full access via app_metadata role check. No INSERT/UPDATE/DELETE policies — writes via service role.
  - Indexes on show_id and is_active
  - Updated_at trigger (reuse update_updated_at from 001_shows.sql)

  **Part B: fee_purchases table**
  - id (uuid PK, gen_random_uuid)
  - payment_id (uuid nullable FK to payments ON DELETE SET NULL)
  - fee_type_id (uuid NOT NULL FK to additional_fee_types)
  - quantity (integer NOT NULL DEFAULT 1)
  - unit_price_cents (integer NOT NULL) — snapshot at purchase time
  - total_cents (integer NOT NULL) — quantity * unit_price_cents
  - show_id (uuid nullable FK to shows ON DELETE SET NULL)
  - purchaser_name (text NOT NULL)
  - purchaser_email (text NOT NULL)
  - status (text NOT NULL DEFAULT 'pending', CHECK IN ('pending', 'confirmed', 'cancelled'))
  - created_at, updated_at (timestamptz NOT NULL DEFAULT now())
  - RLS enabled: SELECT-only for authenticated users where email matches their member email or admin. No INSERT/UPDATE/DELETE — writes via service role.
  - Indexes on payment_id, fee_type_id, purchaser_email
  - Updated_at trigger

  **Part C: ALTER payments table for guest support**
  - ALTER COLUMN member_id DROP NOT NULL (make nullable for guest payments)
  - ADD COLUMN guest_email TEXT
  - ADD COLUMN guest_name TEXT
  - Drop existing payment_type CHECK constraint and recreate to include all 4 types: 'membership_dues', 'membership_renewal', 'entry_fees', 'additional_fees'
  - Add index on guest_email for guest payment lookup
  - Update payments RLS: the existing policies use `auth.uid() = member_id` which naturally handles null member_id (null != uid, so guests can't see other payments). No additional policies needed — guest payment lookup handled via admin client on success page.

  Follow established migration patterns from 006_payments.sql and 008_show_entries.sql.
  </action>
  <verify>Review migration SQL for syntax, verify all FKs reference correct tables, CHECK constraints include all needed values</verify>
  <done>Migration 009 created with additional_fee_types table, fee_purchases table, and payments ALTER for guest support — correct FKs, CHECK constraints, RLS, indexes, and triggers</done>
</task>

<task type="auto">
  <name>Task 2: Add TypeScript types and fee items CRUD + query server actions</name>
  <files>src/types/database.ts, src/lib/actions/fee-items.ts</files>
  <action>
  **In database.ts, add after ShowEntryClassRow section:**

  FeeItemRow interface matching additional_fee_types schema:
  - id: string, name: string, description: string | null, price_cents: number, category: string, show_id: string | null, max_quantity_per_order: number | null, is_active: boolean, sort_order: number, created_at: string, updated_at: string

  FeeItemInsert type: Omit<FeeItemRow, 'id' | 'created_at' | 'updated_at'>

  FeePurchaseRow interface matching fee_purchases schema:
  - id: string, payment_id: string | null, fee_type_id: string, quantity: number, unit_price_cents: number, total_cents: number, show_id: string | null, purchaser_name: string, purchaser_email: string, status: string, created_at: string, updated_at: string

  Update PaymentRow:
  - member_id: string | null (was string)
  - Add guest_email: string | null
  - Add guest_name: string | null
  - Update payment_type comment to note 'additional_fees' as valid value

  **In fee-items.ts ('use server'), create 6 server actions:**

  1. getFeeItems() — Admin only: fetch all fee items ordered by sort_order. Check admin role via getUser() + app_metadata. Use admin client for consistent access. Return FeeItemRow[].

  2. getActiveFeeItems() — Public: fetch active fee items (is_active = true) ordered by sort_order. Use admin client (anon RLS allows SELECT, but admin client is more reliable). No auth required.

  3. getActiveFeeItemsForShow(showId: string) — Public: fetch active fee items where show_id matches OR show_id IS NULL (general items). Combine with .or() filter. No auth required.

  4. createFeeItem(data: FeeItemInsert) — Admin only: validate admin role, validate required fields (name non-empty, price_cents > 0), insert via admin client, revalidate /admin/fees. Return { success: true } | { error: string }.

  5. updateFeeItem(id: string, data: Partial<FeeItemInsert>) — Admin only: validate admin role, update via admin client, revalidate /admin/fees. Return { success: true } | { error: string }.

  6. deleteFeeItem(id: string) — Admin only: validate admin role, delete via admin client, revalidate /admin/fees. Return { success: true } | { error: string }.

  Follow patterns from show-classes.ts for CRUD structure. Use sanitizeSupabaseError for error handling. Import createClient from supabase/server for auth checks, createAdminClient for writes.
  </action>
  <verify>npx tsc --noEmit passes, all 6 actions exported from fee-items.ts</verify>
  <done>FeeItemRow, FeePurchaseRow types added to database.ts, PaymentRow updated with nullable member_id + guest fields, 6 fee item actions exported and type-safe</done>
</task>

<task type="auto">
  <name>Task 3: Create fee checkout server action and update fulfillment handler</name>
  <files>src/lib/actions/fee-checkout.ts, src/lib/actions/fulfillment.ts</files>
  <action>
  **In fee-checkout.ts ('use server'), create:**

  createFeeCheckoutSession(input: { items: Array<{feeTypeId: string, quantity: number}>, showId?: string, guestEmail?: string, guestName?: string }) returning { url: string } | { error: string }

  Flow:
  1. Validate items: non-empty array, each feeTypeId non-blank, each quantity >= 1
  2. Try to get authenticated user via createClient().auth.getUser() — NOT an error if user is null (guest flow)
  3. If authenticated: fetch member profile from members table, get/create Stripe customer (follow entry-checkout.ts pattern exactly — create customer with metadata.member_id, store stripe_customer_id)
  4. If NOT authenticated: require guestEmail and guestName from input (return error if missing). Validate email format with basic regex.
  5. Fetch fee types by IDs via admin client. Validate all IDs exist and are active. Check quantities against max_quantity_per_order (if set).
  6. Calculate total: sum of (fee.price_cents * quantity) for each item
  7. Build Stripe line items: one per fee type, with price_data { currency: 'usd', unit_amount: fee.price_cents, product_data: { name: fee.name, description: fee.description or fee.category } }, quantity from input
  8. Determine URLs: if authenticated, success_url = /member/checkout/success?session_id={CHECKOUT_SESSION_ID}, cancel_url = /member/checkout/cancel?return=fees. If guest, success_url = /purchase/success?session_id={CHECKOUT_SESSION_ID}, cancel_url = /purchase/cancel
  9. Create Stripe Checkout Session: mode 'payment', customer (member) or customer_email (guest), line_items, metadata { payment_type: 'additional_fees', member_id: memberId or '', guest_email: guestEmail or '', guest_name: guestName or '', show_id: showId or '' }, success_url, cancel_url
  10. Insert pending payment via admin client: member_id (or null for guests), guest_email, guest_name, amount_cents: total, payment_type: 'additional_fees', membership_type_slug: null, stripe_checkout_session_id: session.id, status: 'pending', description: 'SWMRHA Additional Fee Purchase'
  11. Capture paymentRecordId from insert
  12. Insert fee_purchase records via admin client: one per item, each with payment_id, fee_type_id, quantity, unit_price_cents (snapshot from fee type), total_cents (quantity * unit_price_cents), show_id, purchaser_name (member name or guestName), purchaser_email (member email or guestEmail), status: 'pending'
  13. Return { url: session.url }

  Wrap in try/catch, return { error: 'Unable to start checkout. Please try again.' } on unexpected errors. Use sanitizeSupabaseError for DB errors.

  **Also in fee-checkout.ts, create:**

  getFeePurchasesByPayment(paymentId: string) — Uses admin client to fetch fee purchases by payment_id. Returns FeePurchaseRow[]. Used by success pages.

  **In fulfillment.ts, update:**

  1. In the payment type dispatch section (line ~117), add 'additional_fees' case:
     ```
     if (paymentType === 'entry_fees') {
       await fulfillEntryPayment(session, admin, paymentRecordId);
     } else if (paymentType === 'additional_fees') {
       await fulfillFeePurchase(session, admin, paymentRecordId);
     } else {
       await fulfillMembershipPayment(session, admin, memberId, membershipTypeSlug);
     }
     ```

  2. Create fulfillFeePurchase(session, admin, paymentRecordId) helper:
     - If no paymentRecordId, log error and return (fee purchases linked via payment)
     - Update all fee_purchases with matching payment_id to status: 'confirmed'
     - Revalidate paths: '/purchase', '/member/purchase', '/member'
     - Log success count

  3. Update fallback payment creation: handle null memberId for guest payments. Currently the fallback checks `if (memberId)` which works — but add else branch that creates guest fallback using guest_email/guest_name from session metadata:
     ```
     if (memberId) { ... existing logic ... }
     else if (paymentType === 'additional_fees') {
       // Guest payment fallback
       insert with member_id: null, guest_email from metadata, guest_name from metadata
     }
     ```

  4. Update the final log line to handle null memberId: `for ${memberId ? 'member' : 'guest'} ${memberId ?? session.metadata?.guest_email}`
  </action>
  <verify>npx tsc --noEmit passes, npm run build succeeds, createFeeCheckoutSession exported from fee-checkout.ts, fulfillment.ts handles 'additional_fees' in dispatch and fallback</verify>
  <done>Fee checkout action handles both member and guest flows, fulfillment dispatches additional_fees to fulfillFeePurchase, guest fallback payment creation works with null member_id</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] `npm run build` succeeds without errors
- [ ] Migration 009 SQL is syntactically valid with correct FKs and CHECK constraints
- [ ] FeeItemRow and FeePurchaseRow in database.ts match migration schema
- [ ] PaymentRow updated with nullable member_id and guest_email/guest_name fields
- [ ] 6 fee item CRUD/query actions exported from fee-items.ts
- [ ] createFeeCheckoutSession handles both authenticated and guest flows
- [ ] Fulfillment handler dispatches 'additional_fees' to fulfillFeePurchase
- [ ] Fallback payment creation handles null member_id for guest payments
- [ ] All writes use admin client (service role)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Migration covers all 3 schema changes (new tables + ALTER payments)
- Checkout action supports both member and guest flows
- Fulfillment handler updated for new payment type with guest support
  </success_criteria>

<output>
After completion, create `.planning/phases/20-guest-checkout-additional-fees/20-01-SUMMARY.md`
</output>
