---
phase: 11-sponsor-management
plan: 01
type: execute
depends_on: []
files_modified: [supabase/migrations/002_sponsors.sql, src/types/database.ts, src/lib/actions/sponsors.ts]
---

<objective>
Create Supabase sponsors table with RLS policies, Supabase Storage bucket for logo uploads, TypeScript types, and CRUD server actions — the data foundation for sponsor management.

Purpose: Establish the complete data layer (database + storage + actions) so admin UI and public page migration can proceed in parallel.
Output: SQL migration with seed data, database types, 5+ server actions including image upload/delete helpers.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries (established patterns):
@.planning/phases/10-show-schedule-management/10-01-SUMMARY.md

# Key source files (follow these patterns exactly):
@supabase/migrations/001_shows.sql
@src/types/database.ts
@src/lib/actions/shows.ts
@src/lib/supabase/server.ts
@src/data/sponsors.ts

**Tech stack available:** Next.js 16, Supabase (auth + DB), TypeScript, Tailwind v4
**Established patterns:** JSONB arrays, RLS (public read + admin write), manual TypeScript types, server actions with error objects, revalidatePath for cache busting
**Constraining decisions:**
- Phase 09-01: Three Supabase client pattern (browser/server/middleware)
- Phase 09-01: RBAC via app_metadata.role === 'admin'
- Phase 10-01: JSONB for flexible arrays, RLS public read + admin write
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sponsors table SQL migration with Storage bucket and seed data</name>
  <files>supabase/migrations/002_sponsors.sql</files>
  <action>
Create SQL migration file following the 001_shows.sql pattern exactly.

**Sponsors table:**
```sql
CREATE TABLE sponsors (
  id          uuid        PRIMARY KEY DEFAULT gen_random_uuid(),
  name        text        NOT NULL,
  level       text        NOT NULL,        -- 'Platinum','Diamond','Gold','Silver','Bronze','Friends'
  image_url   text,                        -- Public URL of logo (Supabase Storage or legacy /images/ path)
  website_url text,                        -- External website link
  sort_order  integer     NOT NULL DEFAULT 0,
  created_at  timestamptz NOT NULL DEFAULT now(),
  updated_at  timestamptz NOT NULL DEFAULT now()
);
```

**RLS policies** (same pattern as shows):
- Enable RLS on sponsors table
- SELECT: public (USING true) — anyone can read sponsors
- INSERT: authenticated + admin role check via `(auth.jwt()->'app_metadata'->>'role') = 'admin'`
- UPDATE: authenticated + admin role (both USING and WITH CHECK)
- DELETE: authenticated + admin role

**updated_at trigger:** Reuse the same `update_updated_at()` function from 001_shows.sql (use CREATE OR REPLACE or IF NOT EXISTS). Apply trigger to sponsors table.

**Supabase Storage bucket:**
```sql
INSERT INTO storage.buckets (id, name, public) VALUES ('sponsor-logos', 'sponsor-logos', true);
```

**Storage RLS policies:**
- SELECT on storage.objects: public read for sponsor-logos bucket
- INSERT on storage.objects: authenticated + admin role for sponsor-logos bucket
- UPDATE on storage.objects: authenticated + admin role for sponsor-logos bucket
- DELETE on storage.objects: authenticated + admin role for sponsor-logos bucket

**Seed data:** Insert all 12 sponsors from src/data/sponsors.ts with their current image paths (e.g., '/images/sponsors/its-all-about-ruf.jpg') as image_url. Set sort_order by tier priority: Platinum=0, Diamond=10, Gold=20, Silver=30, Bronze=40. Within each tier, order alphabetically. Use exact names, levels, URLs, and image paths from the static data file.
  </action>
  <verify>
Review the SQL file for:
1. Table has all 6 columns plus id/timestamps
2. RLS enabled with 4 policies matching shows pattern
3. Storage bucket created with public=true
4. Storage has 4 RLS policies (SELECT/INSERT/UPDATE/DELETE)
5. All 12 sponsors seeded with correct tier sort_order values
6. updated_at trigger applied
  </verify>
  <done>SQL migration file exists with sponsors table, RLS, Storage bucket + policies, trigger, and 12 seeded sponsors</done>
</task>

<task type="auto">
  <name>Task 2: Create TypeScript types and CRUD server actions with image upload</name>
  <files>src/types/database.ts, src/lib/actions/sponsors.ts</files>
  <action>
**Add to src/types/database.ts** (append after ShowUpdate type):

```typescript
/** A full row from the `sponsors` table. */
export interface SponsorRow {
  id: string;
  name: string;
  level: string;
  image_url: string | null;
  website_url: string | null;
  sort_order: number;
  created_at: string;
  updated_at: string;
}

/** Fields required to insert a new sponsor. */
export type SponsorInsert = Omit<SponsorRow, 'id' | 'created_at' | 'updated_at'>;

/** Fields allowed when updating a sponsor. */
export type SponsorUpdate = Partial<SponsorInsert> & { id: string };
```

**Create src/lib/actions/sponsors.ts** following src/lib/actions/shows.ts pattern exactly:

1. `getSponsors()` — SELECT all, ORDER BY sort_order ASC, name ASC. Returns `SponsorRow[] | { error: string }`.

2. `getSponsor(id: string)` — SELECT single by id. Returns `SponsorRow | null | { error: string }`.

3. `createSponsor(data: SponsorInsert)` — INSERT with validation (name and level required, trim whitespace). Revalidate `/admin/sponsors` and `/sponsors`. Returns `SponsorRow | { error: string }`.

4. `updateSponsor(data: SponsorUpdate)` — UPDATE with only provided fields. Validate id required. Revalidate paths. Returns `SponsorRow | { error: string }`.

5. `deleteSponsor(id: string)` — First fetch the sponsor to get image_url. If image_url starts with the Supabase Storage URL pattern (contains '/storage/v1/object/public/sponsor-logos/'), extract the path and delete from Storage. Then DELETE the row. Revalidate paths. Returns `{ success: boolean } | { error: string }`.

6. `uploadSponsorLogo(formData: FormData)` — Extract file from FormData. Generate unique filename using `${Date.now()}-${originalName}`. Upload to 'sponsor-logos' bucket via `supabase.storage.from('sponsor-logos').upload(path, file)`. Return public URL via `supabase.storage.from('sponsor-logos').getPublicUrl(path)`. Returns `{ url: string } | { error: string }`.

7. `deleteSponsorLogo(path: string)` — Delete file from 'sponsor-logos' bucket. Returns `{ success: boolean } | { error: string }`.

All actions use `'use server'` directive and `createClient()` from `@/lib/supabase/server`. Error handling returns `{ error: string }` objects (not thrown exceptions), matching the shows pattern.
  </action>
  <verify>
1. TypeScript compilation check: Verify no type errors in database.ts and sponsors.ts
2. Review that all 7 actions follow the shows.ts error handling pattern
3. Verify revalidatePath calls cover both admin and public routes
4. Verify deleteSponsor cleans up Storage images
  </verify>
  <done>SponsorRow/SponsorInsert/SponsorUpdate types added to database.ts. sponsors.ts has 7 server actions (5 CRUD + 2 image) with proper error handling, revalidation, and Storage cleanup on delete.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] SQL migration file has correct table schema, RLS, Storage bucket, and seed data
- [ ] TypeScript types match the SQL schema
- [ ] All 7 server actions created with consistent error handling
- [ ] Image upload returns public URL, delete cleans up Storage
- [ ] No TypeScript errors introduced
</verification>

<success_criteria>

- sponsors table defined with RLS matching shows pattern
- Supabase Storage bucket 'sponsor-logos' with admin-only write policies
- 12 sponsors seeded from static data
- 7 server actions: getSponsors, getSponsor, createSponsor, updateSponsor, deleteSponsor, uploadSponsorLogo, deleteSponsorLogo
- All actions follow established error handling pattern
</success_criteria>

<output>
After completion, create `.planning/phases/11-sponsor-management/11-01-SUMMARY.md`
</output>
