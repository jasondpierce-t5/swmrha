---
phase: 12-results-standings-management
plan: 01
type: execute
depends_on: []
files_modified: [supabase/migrations/003_results.sql, src/types/database.ts, src/lib/actions/results.ts]
---

<objective>
Create the results database table, RLS policies, TypeScript types, and CRUD server actions for managing show results and standings links.

Purpose: Establish the data layer for results management, replacing the static `resultsLinks` array in `src/data/shows.ts` with a Supabase-backed table that admins can manage dynamically.
Output: Working results table with RLS, typed interfaces, and 5 server actions (getResults, getResult, createResult, updateResult, deleteResult) with seed data from existing static content.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase patterns (follow exactly):
@supabase/migrations/001_shows.sql
@supabase/migrations/002_sponsors.sql
@src/types/database.ts
@src/lib/actions/shows.ts
@src/lib/actions/sponsors.ts

# Current static data to migrate:
@src/data/shows.ts

**Tech stack available:** Next.js 16.1.6, Supabase (PostgreSQL + RLS), TypeScript, @supabase/ssr
**Established patterns:** server-actions-crud, rls-admin-write-public-read, manual TypeScript types in database.ts
**Constraining decisions:**
- Phase 10: JSONB for flexible data — but results don't need JSONB, they're simple text fields
- Phase 10: RLS public read + admin write pattern — follow exactly
- Phase 11: Sort order by bands — results use simple integer sort_order
- Phase 09: Three Supabase client pattern (browser/server/middleware) — already established
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create results table SQL migration with RLS and seed data</name>
  <files>supabase/migrations/003_results.sql</files>
  <action>
Create migration file following the exact pattern from 001_shows.sql and 002_sponsors.sql.

**Table schema — `results`:**
- `id` uuid PRIMARY KEY DEFAULT gen_random_uuid()
- `label` text NOT NULL — display name (e.g., "2025 Rt 66 Slide Results")
- `url` text NOT NULL — external link URL
- `category` text NOT NULL — one of: 'current_year', 'past_results', 'standings' (used for grouping on public page, replaces the label-parsing logic in the current static page)
- `sort_order` integer NOT NULL DEFAULT 0
- `created_at` timestamptz NOT NULL DEFAULT now()
- `updated_at` timestamptz NOT NULL DEFAULT now()

**RLS policies** (same pattern as shows/sponsors):
- Public SELECT (anon + authenticated)
- Admin-only INSERT, UPDATE, DELETE using `(auth.jwt()->'app_metadata'->>'role') = 'admin'`

**updated_at trigger:** Reuse the `update_updated_at()` function from 001_shows.sql (CREATE OR REPLACE).

**Seed data** from `src/data/shows.ts` `resultsLinks` array — 6 rows:
1. "2025 Rt 66 Slide Results" → category: 'current_year', sort_order: 0
2. "2024 Year End Champions" → category: 'past_results', sort_order: 10
3. "2024 Show Results" → category: 'past_results', sort_order: 11
4. "RESULTS 2024 Patriot Slide Show" → category: 'past_results', sort_order: 12
5. "Photos from 2023 Patriot Slide Show" → category: 'past_results', sort_order: 13
6. "Current GAG Standings" → category: 'standings', sort_order: 20

Do NOT add storage bucket (results are links, not file uploads). Do NOT use JSONB (simple text columns suffice).
  </action>
  <verify>Review SQL file for correct syntax, RLS policies match shows/sponsors pattern, all 6 seed rows present with correct URLs from src/data/shows.ts</verify>
  <done>Migration file exists with table, RLS policies (4), trigger, and 6 seed rows. SQL is valid PostgreSQL syntax.</done>
</task>

<task type="auto">
  <name>Task 2: Add ResultRow types and create CRUD server actions</name>
  <files>src/types/database.ts, src/lib/actions/results.ts</files>
  <action>
**In src/types/database.ts** — append after SponsorUpdate type (follow existing pattern exactly):

```
// Results table
export interface ResultRow {
  id: string;
  label: string;
  url: string;
  category: string;
  sort_order: number;
  created_at: string;
  updated_at: string;
}
export type ResultInsert = Omit<ResultRow, 'id' | 'created_at' | 'updated_at'>;
export type ResultUpdate = Partial<ResultInsert> & { id: string };
```

**In src/lib/actions/results.ts** — follow shows.ts pattern exactly with these 5 functions:

1. `getResults()` — SELECT * ordered by category ASC, sort_order ASC (groups categories together, then by order within)
2. `getResult(id)` — SELECT single by ID with maybeSingle()
3. `createResult(data: ResultInsert)` — validate label and url required, validate category is one of ['current_year', 'past_results', 'standings'], insert with defaults
4. `updateResult(data: ResultUpdate)` — partial update pattern (only send provided fields), validate category if provided
5. `deleteResult(id)` — delete by ID

All write operations call `revalidatePath('/admin/results')` and `revalidatePath('/results')`.

Follow the exact error handling pattern: return `{ error: string }` on failure. Use `createClient` from `@/lib/supabase/server`. Import types from `@/types/database`.

Do NOT add image upload actions (results are links only). Keep it simple — no JSONB, no complex nested data.
  </action>
  <verify>TypeScript compilation check — ensure no type errors in the new files. Verify all 5 functions are exported, return types match pattern.</verify>
  <done>ResultRow/ResultInsert/ResultUpdate types added to database.ts. 5 server actions in results.ts with proper validation, error handling, and path revalidation.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] SQL migration file has correct table schema with all 6 columns
- [ ] 4 RLS policies (select, insert, update, delete) matching shows/sponsors pattern
- [ ] updated_at trigger present
- [ ] 6 seed rows with correct labels, URLs, categories, and sort orders
- [ ] TypeScript types added (ResultRow, ResultInsert, ResultUpdate)
- [ ] 5 server actions (getResults, getResult, createResult, updateResult, deleteResult)
- [ ] Category validation in createResult and updateResult
- [ ] revalidatePath calls on all write operations
- [ ] No TypeScript compilation errors
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors introduced
- Server actions follow exact same patterns as shows.ts and sponsors.ts
- SQL migration follows exact same patterns as 001_shows.sql and 002_sponsors.sql
</success_criteria>

<output>
After completion, create `.planning/phases/12-results-standings-management/12-01-SUMMARY.md`
</output>
