---
phase: 17-membership-payments
plan: 01
type: execute
depends_on: []
files_modified: [supabase/migrations/006_payments.sql, src/types/database.ts, src/lib/supabase/admin.ts, src/lib/actions/payments.ts, src/lib/actions/checkout.ts, .env.local.example]
domain: null
---

<objective>
Create payments database table, Supabase admin client for webhook/system operations, and Stripe checkout session server action for membership dues.

Purpose: Establish the data layer and checkout flow that enables members to pay membership dues via Stripe Checkout.
Output: Payments migration, TypeScript types, admin Supabase client, checkout session action, payment query actions.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context (Stripe foundation + membership types):
@.planning/phases/14-stripe-foundation-member-auth/14-01-SUMMARY.md
@.planning/phases/16-membership-management/16-01-SUMMARY.md

# Key source files:
@src/lib/stripe/server.ts
@src/lib/stripe/client.ts
@src/lib/supabase/server.ts
@src/types/database.ts
@src/lib/actions/membership-types.ts
@src/lib/actions/members.ts
@supabase/migrations/004_members_table.sql
@supabase/migrations/005_membership_types.sql
@.env.local.example

**Tech stack available:** stripe, @stripe/stripe-js, @stripe/react-stripe-js, @supabase/ssr, @supabase/supabase-js
**Established patterns:**
- Stripe server singleton: `getStripeServer()` from `@/lib/stripe/server`
- Supabase SSR client: `createClient()` from `@/lib/supabase/server`
- Database types: manual interfaces in `src/types/database.ts`
- Server actions: `'use server'` with `sanitizeSupabaseError`, input validation, `revalidatePath`
- Migrations: sequential numbering (001-005 used)
- RLS: members read own rows, admins full CRUD, public read for active types

**Constraining decisions:**
- Phase 14: Stripe SDK default API version, singleton patterns, webhook returns 200 always
- Phase 16: membership_types loosely coupled via slug (no FK), price_cents integer storage
- Phase 15: updateMemberProfile restricts fields to name/phone/address (system fields managed separately)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create payments table migration, types, and Supabase admin client</name>
  <files>supabase/migrations/006_payments.sql, src/types/database.ts, src/lib/supabase/admin.ts, .env.local.example</files>
  <action>
1. Create `supabase/migrations/006_payments.sql`:
   - Table `public.payments` with columns:
     - `id` UUID DEFAULT gen_random_uuid() PRIMARY KEY
     - `member_id` UUID NOT NULL REFERENCES public.members(id) ON DELETE CASCADE
     - `amount_cents` INTEGER NOT NULL
     - `payment_type` TEXT NOT NULL CHECK (payment_type IN ('membership_dues', 'membership_renewal'))
     - `membership_type_slug` TEXT
     - `description` TEXT
     - `stripe_checkout_session_id` TEXT UNIQUE
     - `stripe_payment_intent_id` TEXT
     - `status` TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'succeeded', 'failed', 'refunded'))
     - `created_at` TIMESTAMPTZ DEFAULT now() NOT NULL
     - `updated_at` TIMESTAMPTZ DEFAULT now() NOT NULL
   - Enable RLS
   - Policy: "Members can read own payments" — SELECT WHERE auth.uid() = member_id
   - Policy: "Admins can read all payments" — SELECT WHERE role = 'admin' (same pattern as admin-members)
   - Policy: "Service role can manage payments" — FOR ALL USING (auth.uid() IS NULL) — allows service-role-key operations (webhook handler). Use a permissive policy that checks `auth.uid() IS NULL` which is true for service role connections, OR use `TO service_role` syntax if supported. Safest approach: create INSERT/UPDATE policies for authenticated users checking member_id = auth.uid() for self-inserts, plus admin full access. But since we want ONLY system-managed writes, use: no INSERT/UPDATE/DELETE policies for regular users, only SELECT. The admin client bypasses RLS via service role key.
   - Updated_at trigger reusing `trigger_set_updated_at()` function from previous migrations
   - Add index on member_id for query performance
   - Add index on stripe_checkout_session_id for webhook lookups

2. Add `PaymentRow` interface to `src/types/database.ts` following existing pattern:
   ```
   interface PaymentRow {
     id: string;
     member_id: string;
     amount_cents: number;
     payment_type: string;
     membership_type_slug: string | null;
     description: string | null;
     stripe_checkout_session_id: string | null;
     stripe_payment_intent_id: string | null;
     status: string;
     created_at: string;
     updated_at: string;
   }
   ```

3. Create `src/lib/supabase/admin.ts` — a Supabase client using the service role key for server-side operations without user auth context (webhooks, system updates):
   ```
   import { createClient } from '@supabase/supabase-js';

   export function createAdminClient() {
     const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
     const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
     if (!supabaseUrl || !serviceRoleKey) {
       throw new Error('Missing SUPABASE_SERVICE_ROLE_KEY or SUPABASE_URL');
     }
     return createClient(supabaseUrl, serviceRoleKey, {
       auth: { autoRefreshToken: false, persistSession: false }
     });
   }
   ```
   This bypasses RLS entirely — use ONLY in server-side code (webhooks, system actions). Never expose to client.

4. Update `.env.local.example` — add `SUPABASE_SERVICE_ROLE_KEY=your-supabase-service-role-key` (NOT prefixed with NEXT_PUBLIC_ to keep server-only).
  </action>
  <verify>npx tsc --noEmit passes, migration SQL syntax valid (no runtime check needed — applied via Supabase Dashboard)</verify>
  <done>PaymentRow type exists in database.ts, migration file at 006, admin client importable from @/lib/supabase/admin, .env.local.example updated</done>
</task>

<task type="auto">
  <name>Task 2: Create Stripe checkout session and payment query server actions</name>
  <files>src/lib/actions/checkout.ts, src/lib/actions/payments.ts</files>
  <action>
1. Create `src/lib/actions/checkout.ts` with `'use server'` directive:

   Export `createCheckoutSession(membershipTypeSlug: string)`:
   - Authenticate: get user via `createClient()` from supabase/server, verify auth
   - Get member profile: query members table for current user
   - Get membership type: query membership_types table for the slug, verify it's active
   - Create or retrieve Stripe customer:
     - If member has `stripe_customer_id`, use it
     - If not, call `stripe.customers.create({ email, name, metadata: { member_id } })`
     - Store new customer ID in members table via admin client
   - Create Stripe Checkout Session:
     - `mode: 'payment'`
     - `customer: customerId`
     - `line_items: [{ price_data: { currency: 'usd', unit_amount: membershipType.price_cents, product_data: { name: 'SWMRHA ${type.name} Membership', description: type.description || undefined } }, quantity: 1 }]`
     - `metadata: { member_id: member.id, membership_type_slug: membershipType.slug, payment_type: 'membership_dues' }`
     - `success_url: '${NEXT_PUBLIC_APP_URL}/member/checkout/success?session_id={CHECKOUT_SESSION_ID}'`
     - `cancel_url: '${NEXT_PUBLIC_APP_URL}/member/checkout/cancel'`
   - Insert pending payment record via admin client:
     - `member_id, amount_cents, payment_type: 'membership_dues', membership_type_slug, stripe_checkout_session_id: session.id, status: 'pending', description`
   - Return `{ url: session.url }` on success or `{ error: string }` on failure
   - Use try/catch with meaningful error messages. Do NOT expose Stripe errors to client — log and return generic message.
   - Determine payment_type based on member's current status: if membership_status is 'active' or 'expired', use 'membership_renewal'; if 'pending', use 'membership_dues'.

2. Create `src/lib/actions/payments.ts` with `'use server'` directive:

   Export `getMemberPayments()`:
   - Get authenticated user via createClient()
   - Query payments table WHERE member_id = user.id, ordered by created_at DESC
   - Return PaymentRow[] or { error: string }

   Export `getPaymentBySessionId(sessionId: string)` (used by success page):
   - Get authenticated user
   - Query payments WHERE stripe_checkout_session_id = sessionId AND member_id = user.id
   - Return single PaymentRow or null

   Follow established patterns: sanitizeSupabaseError for DB errors, input validation for sessionId.
  </action>
  <verify>npx tsc --noEmit passes, both action files export expected functions</verify>
  <done>createCheckoutSession returns { url } or { error }, getMemberPayments returns payment array, getPaymentBySessionId returns single payment or null, all type-safe</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] `npm run build` succeeds without errors
- [ ] PaymentRow interface in database.ts matches migration schema
- [ ] Admin client created with service role key pattern
- [ ] Checkout action creates Stripe session with correct line_items and metadata
- [ ] Payment query actions properly scoped to authenticated member
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Payments migration ready for Supabase Dashboard execution
- Checkout session action ready for UI integration
- Payment query actions ready for payment history page
</success_criteria>

<output>
After completion, create `.planning/phases/17-membership-payments/17-01-SUMMARY.md`
</output>
